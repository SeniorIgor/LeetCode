# 2721. Execute Asynchronous Functions in Parallel (Without Promise.all)

## Intuition
Each function in the input array returns a promise, and all of them must be executed **in parallel**.
The goal is to replicate the behavior of `Promise.all` without using it:
- Start all promises immediately
- Preserve the order of results
- Resolve only when all promises resolve
- Reject as soon as any promise rejects

## Approach
1. Create and return a new `Promise`.
2. Initialize:
   - a result array to store resolved values by index
   - a counter to track how many promises have resolved
3. Iterate through the array of functions:
   - Call each function immediately to start execution in parallel
   - On resolution, store the value at the correct index and increment the counter
   - When all promises resolve, resolve the outer promise
   - On rejection, immediately reject the outer promise with the error
4. Since all functions are invoked in the loop, all promises run in parallel.

## Complexity
- **Time complexity:** O(n)  
  (Each promise is handled once; total time depends on the slowest promise.)
- **Space complexity:** O(n)  
  (Required to store the resolved results.)

## Code
```typescript
type Fn<T> = () => Promise<T>;

function promiseAll<T>(functions: Fn<T>[]): Promise<T[]> {
  return new Promise((resolve, reject) => {
    const n = functions.length;
    const result = new Array<T>(n);
    let completed = 0;

    for (let i = 0; i < n; i++) {
      functions[i]()
        .then((value) => {
          result[i] = value;
          completed++;

          if (completed === n) {
            resolve(result);
          }
        })
        .catch((error) => {
          reject(error);
        });
    }
  });
}

/**
 * const promise = promiseAll([() => new Promise(res => res(42))]);
 * promise.then(console.log); // [42]
 */
```
